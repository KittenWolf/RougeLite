import Tile from "./lib/tile.js";
import Point from "./lib/point.js";
import Layout from "./layout.js";
import { getRandomNumber } from "./lib/functions.js";

import { Room } from "./map/room.js";
import { Corridor } from "./map/corridor.js";

import { GameObjects, gameObjectsList } from "./lib/gameObjects.js";
import { Wall } from "./environment/obstacles.js";
import { Floor } from "./environment/playground.js";
import { Rouge } from "./characters/enemies.js";
import { HealthPotion } from "./items/collectable.js";
import { Sword } from "./items/consumable.js";
import { Player } from "./characters/player.js";

export class Scene {
    #layout;
    #configuaration = config.scene;

    get width() {
        return config.scene.width;
    };
    get height() {
        return config.scene.heigth;
    };

    name = config.scene.name ?? "Autogenerated map";

    constructor() { 
        GameObjects.reset();
        this.#layout = new Layout();
    }

    addGameObject(obj) {        
        GameObjects.add(obj);
        this.#layout.updateNode(obj);
    }

    removeGameObject(point) {        
        GameObjects.delete(point);
        this.#layout.resetNode(point);
    }

    reset() {
        GameObjects.reset();
        this.#layout.resetNodes();
    }

    //#region Generation
    generate() {
        console.time("Generation time");

        this.reset();

        if (this.#configuaration.hasRooms) {
            let rooms = this.generateRooms();

            rooms.forEach(room => {
                for (let y = 0; y < room.height; y++) {
                    for (let x = 0; x < room.width; x++) {
                        let objX = room.point.x + x;
                        let objY = room.point.y + y;

                        let point = new Point(objX, objY);

                        GameObjects.add(new Floor(point));
                    }
                }
            });
        } else {
            // generate corridors system
        }

        // this.generateGameObjects();
        this.generatePlayerSpawn();

        this.#layout.renderScene();

        console.timeEnd("Generation time");
    }

    generatePlayerSpawn() {
        let playground = GameObjects.list.environment.playground;
        let randomTileIndex = getRandomNumber(playground.length, 0);
        let point = playground[randomTileIndex].tile.point;

        GameObjects.add(new Player(point));
    }

    generateGameObjects() {
        gameObjectsList.forEach(obj => {
            let count = this.playableTiles.length * obj.spreadMultiplier / 10;
        });
    }

    generateRooms() {
        let rooms = [];
        let playArea = this.width * this.height * this.#configuaration.playgroundMultiplier;

        this.generateRoom(rooms, playArea);
        this.spreadRooms(rooms);

        return rooms;
    }

    generateRoom(rooms, playArea) {
        let min = this.#configuaration.room.minRoomSideLength;
        let max = this.#configuaration.room.maxRoomSideLength;

        let width = getRandomNumber(max, min);
        let height = getRandomNumber(max, min);

        let area = width * height;

        if (area > playArea) return;

        let room = new Room(new Point(0, 0), width, height);
        playArea -= area;

        rooms.push(room);

        return this.generateRoom(rooms, playArea);
    }

    spreadRooms(rooms) {
        let totalTiles = this.width * this.height;
        let count = rooms.length;
        let area = totalTiles / count;

        let sideLength = Math.floor(Math.sqrt(area));
        let rows = Math.round(this.height / sideLength);
        let columns = Math.round(this.width / sideLength);

        if (rows * columns < count) {
            columns += 1;
        }

        let columnWidth = Math.round(this.width / columns);
        let rowHeght = Math.round(this.height / rows);

        let startX = 0;
        let startY = 0;
        let endX = columnWidth;
        let endY = rowHeght;

        let columnCounter = 0;

        for (let i = 0; i < count; i++) {
            if (columnCounter >= columns) {
                columnCounter = 0;
                startY += rowHeght;
                endY = startY + rowHeght;
            }

            startX = columnWidth * columnCounter;
            endX = columnWidth * (columnCounter + 1);

            let x = getRandomNumber(endX - rooms[i].width, startX);
            let y = getRandomNumber(endY - rooms[i].height, startY);

            rooms[i].point.x = x;
            rooms[i].point.y = y;

            columnCounter++;
        }
    }
    //#endregion Generation

    swapGameObjects(from, to) {
        console.log(from.tile, to.tile);
        let buffer = to.tile.point;

        GameObjects.matrix[from.tile.point.y][from.tile.point.x] = to;
        GameObjects.matrix[to.tile.point.y][to.tile.point.x] = from;

        to.tile.point = from.tile.point;
        from.tile.point = buffer;

        this.#layout.updateNode(from);
        this.#layout.updateNode(to);
    }
}